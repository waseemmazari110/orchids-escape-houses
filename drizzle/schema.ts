import { sqliteTable, AnySQLiteColumn, foreignKey, integer, text, real, uniqueIndex } from "drizzle-orm/sqlite-core"
  import { sql } from "drizzle-orm"

export const bookings = sqliteTable("bookings", {
	id: integer().primaryKey({ autoIncrement: true }).notNull(),
	propertyName: text("property_name").notNull(),
	propertyLocation: text("property_location"),
	guestName: text("guest_name").notNull(),
	guestEmail: text("guest_email").notNull(),
	guestPhone: text("guest_phone").notNull(),
	checkInDate: text("check_in_date").notNull(),
	checkOutDate: text("check_out_date").notNull(),
	numberOfGuests: integer("number_of_guests").notNull(),
	occasion: text(),
	bookingStatus: text("booking_status").default("pending").notNull(),
	totalPrice: real("total_price"),
	depositAmount: real("deposit_amount"),
	depositPaid: integer("deposit_paid").default(0),
	balanceAmount: real("balance_amount"),
	balancePaid: integer("balance_paid").default(0),
	specialRequests: text("special_requests"),
	experiencesSelected: text("experiences_selected"),
	adminNotes: text("admin_notes"),
	createdAt: text("created_at").notNull(),
	updatedAt: text("updated_at").notNull(),
	propertyId: integer("property_id").references(() => properties.id, { onDelete: "cascade" } ),
	stripeCustomerId: text("stripe_customer_id"),
	stripeDepositPaymentIntentId: text("stripe_deposit_payment_intent_id"),
	stripeBalancePaymentIntentId: text("stripe_balance_payment_intent_id"),
	stripeDepositChargeId: text("stripe_deposit_charge_id"),
	stripeBalanceChargeId: text("stripe_balance_charge_id"),
	stripeRefundId: text("stripe_refund_id"),
	paymentMetadata: text("payment_metadata"),
});

export const account = sqliteTable("account", {
	id: text().primaryKey().notNull(),
	accountId: text("account_id").notNull(),
	providerId: text("provider_id").notNull(),
	userId: text("user_id").notNull().references(() => user.id, { onDelete: "cascade" } ),
	accessToken: text("access_token"),
	refreshToken: text("refresh_token"),
	idToken: text("id_token"),
	accessTokenExpiresAt: integer("access_token_expires_at"),
	refreshTokenExpiresAt: integer("refresh_token_expires_at"),
	scope: text(),
	password: text(),
	createdAt: integer("created_at").notNull(),
	updatedAt: integer("updated_at").notNull(),
});

export const session = sqliteTable("session", {
	id: text().primaryKey().notNull(),
	expiresAt: integer("expires_at").notNull(),
	token: text().notNull(),
	createdAt: integer("created_at").notNull(),
	updatedAt: integer("updated_at").notNull(),
	ipAddress: text("ip_address"),
	userAgent: text("user_agent"),
	userId: text("user_id").notNull().references(() => user.id, { onDelete: "cascade" } ),
},
(table) => [
	uniqueIndex("session_token_unique").on(table.token),
]);

export const user = sqliteTable("user", {
	id: text().primaryKey().notNull(),
	name: text().notNull(),
	email: text().notNull(),
	emailVerified: integer("email_verified").notNull(),
	image: text(),
	createdAt: integer("created_at").notNull(),
	updatedAt: integer("updated_at").notNull(),
	role: text().default("guest").notNull(),
	phone: text(),
	companyName: text("company_name"),
	propertyWebsite: text("property_website"),
	planId: text("plan_id"),
	paymentStatus: text("payment_status").default("pending"),
},
(table) => [
	uniqueIndex("user_email_unique").on(table.email),
]);

export const verification = sqliteTable("verification", {
	id: text().primaryKey().notNull(),
	identifier: text().notNull(),
	value: text().notNull(),
	expiresAt: integer("expires_at").notNull(),
	createdAt: integer("created_at"),
	updatedAt: integer("updated_at"),
});

export const blogPosts = sqliteTable("blog_posts", {
	id: integer().primaryKey({ autoIncrement: true }).notNull(),
	title: text().notNull(),
	slug: text().notNull(),
	excerpt: text().notNull(),
	body: text().notNull(),
	featuredImage: text("featured_image").notNull(),
	category: text().notNull(),
	tags: text(),
	author: text().notNull(),
	seoTitle: text("seo_title"),
	seoDescription: text("seo_description"),
	isPublished: integer("is_published").default(0),
	publishedAt: text("published_at"),
	createdAt: text("created_at").notNull(),
	updatedAt: text("updated_at").notNull(),
},
(table) => [
	uniqueIndex("blog_posts_slug_unique").on(table.slug),
]);

export const destinationImages = sqliteTable("destination_images", {
	id: integer().primaryKey({ autoIncrement: true }).notNull(),
	destinationId: integer("destination_id").notNull().references(() => destinations.id, { onDelete: "cascade" } ),
	imageUrl: text("image_url").notNull(),
	caption: text(),
	orderIndex: integer("order_index").default(0),
	createdAt: text("created_at").notNull(),
});

export const destinations = sqliteTable("destinations", {
	id: integer().primaryKey({ autoIncrement: true }).notNull(),
	cityName: text("city_name").notNull(),
	slug: text().notNull(),
	region: text().notNull(),
	overview: text().notNull(),
	travelTips: text("travel_tips"),
	topVenues: text("top_venues"),
	heroImage: text("hero_image").notNull(),
	mapArea: text("map_area"),
	isPublished: integer("is_published").default(1),
	createdAt: text("created_at").notNull(),
	updatedAt: text("updated_at").notNull(),
},
(table) => [
	uniqueIndex("destinations_slug_unique").on(table.slug),
]);

export const experienceFaqs = sqliteTable("experience_faqs", {
	id: integer().primaryKey({ autoIncrement: true }).notNull(),
	experienceId: integer("experience_id").notNull().references(() => experiences.id, { onDelete: "cascade" } ),
	question: text().notNull(),
	answer: text().notNull(),
	orderIndex: integer("order_index").default(0),
	createdAt: text("created_at").notNull(),
});

export const experienceImages = sqliteTable("experience_images", {
	id: integer().primaryKey({ autoIncrement: true }).notNull(),
	experienceId: integer("experience_id").notNull().references(() => experiences.id, { onDelete: "cascade" } ),
	imageUrl: text("image_url").notNull(),
	orderIndex: integer("order_index").default(0),
	createdAt: text("created_at").notNull(),
});

export const experiences = sqliteTable("experiences", {
	id: integer().primaryKey({ autoIncrement: true }).notNull(),
	title: text().notNull(),
	slug: text().notNull(),
	duration: text().notNull(),
	groupSizeMin: integer("group_size_min").notNull(),
	groupSizeMax: integer("group_size_max").notNull(),
	priceFrom: real("price_from").notNull(),
	description: text().notNull(),
	included: text(),
	whatToProvide: text("what_to_provide"),
	heroImage: text("hero_image").notNull(),
	category: text(),
	isPublished: integer("is_published").default(1),
	createdAt: text("created_at").notNull(),
	updatedAt: text("updated_at").notNull(),
},
(table) => [
	uniqueIndex("experiences_slug_unique").on(table.slug),
]);

export const faqs = sqliteTable("faqs", {
	id: integer().primaryKey({ autoIncrement: true }).notNull(),
	question: text().notNull(),
	answer: text().notNull(),
	category: text().notNull(),
	orderIndex: integer("order_index").default(0),
	isPublished: integer("is_published").default(1),
	createdAt: text("created_at").notNull(),
	updatedAt: text("updated_at").notNull(),
});

export const partners = sqliteTable("partners", {
	id: integer().primaryKey({ autoIncrement: true }).notNull(),
	name: text().notNull(),
	type: text().notNull(),
	region: text(),
	website: text(),
	contactEmail: text("contact_email"),
	commissionNotes: text("commission_notes"),
	isActive: integer("is_active").default(1),
	createdAt: text("created_at").notNull(),
	updatedAt: text("updated_at").notNull(),
});

export const properties = sqliteTable("properties", {
	id: integer().primaryKey({ autoIncrement: true }).notNull(),
	title: text().notNull(),
	slug: text().notNull(),
	location: text().notNull(),
	region: text().notNull(),
	sleepsMin: integer("sleeps_min").notNull(),
	sleepsMax: integer("sleeps_max").notNull(),
	bedrooms: integer().notNull(),
	bathrooms: integer().notNull(),
	priceFromMidweek: real("price_from_midweek").notNull(),
	priceFromWeekend: real("price_from_weekend").notNull(),
	description: text().notNull(),
	houseRules: text("house_rules"),
	checkInOut: text("check_in_out"),
	icalUrl: text("ical_url"),
	heroImage: text("hero_image").notNull(),
	heroVideo: text("hero_video"),
	floorplanUrl: text("floorplan_url"),
	mapLat: real("map_lat"),
	mapLng: real("map_lng"),
	ownerContact: text("owner_contact"),
	featured: integer().default(0),
	isPublished: integer("is_published").default(1),
	createdAt: text("created_at").notNull(),
	updatedAt: text("updated_at").notNull(),
	ownerId: text("owner_id").references(() => user.id, { onDelete: "set null" } ),
	status: text().default("pending").notNull(),
	rejectionReason: text("rejection_reason"),
	approvedBy: text("approved_by").references(() => user.id, { onDelete: "set null" } ),
	approvedAt: text("approved_at"),
	planId: text("plan_id"),
	paymentStatus: text("payment_status").default("pending"),
	stripePaymentIntentId: text("stripe_payment_intent_id"),
	planPurchasedAt: text("plan_purchased_at"),
	planExpiresAt: text("plan_expires_at"),
},
(table) => [
	uniqueIndex("properties_slug_unique").on(table.slug),
]);

export const propertyFeatures = sqliteTable("property_features", {
	id: integer().primaryKey({ autoIncrement: true }).notNull(),
	propertyId: integer("property_id").notNull().references(() => properties.id, { onDelete: "cascade" } ),
	featureName: text("feature_name").notNull(),
	createdAt: text("created_at").notNull(),
});

export const propertyImages = sqliteTable("property_images", {
	id: integer().primaryKey({ autoIncrement: true }).notNull(),
	propertyId: integer("property_id").notNull().references(() => properties.id, { onDelete: "cascade" } ),
	imageUrl: text("image_url").notNull(),
	caption: text(),
	orderIndex: integer("order_index").default(0),
	createdAt: text("created_at").notNull(),
});

export const reviews = sqliteTable("reviews", {
	id: integer().primaryKey({ autoIncrement: true }).notNull(),
	guestName: text("guest_name").notNull(),
	rating: integer().notNull(),
	comment: text().notNull(),
	propertyId: integer("property_id").references(() => properties.id),
	reviewDate: text("review_date").notNull(),
	guestImage: text("guest_image"),
	isApproved: integer("is_approved").default(0),
	isPublished: integer("is_published").default(0),
	createdAt: text("created_at").notNull(),
	updatedAt: text("updated_at").notNull(),
});

export const crmActivityLog = sqliteTable("crm_activity_log", {
	id: integer().primaryKey({ autoIncrement: true }).notNull(),
	entityType: text("entity_type").notNull(),
	entityId: text("entity_id").notNull(),
	activityType: text("activity_type").notNull(),
	title: text().notNull(),
	description: text(),
	outcome: text(),
	performedBy: text("performed_by"),
	metadata: text(),
	createdAt: text("created_at").notNull(),
});

export const crmEnquiries = sqliteTable("crm_enquiries", {
	id: integer().primaryKey({ autoIncrement: true }).notNull(),
	ownerId: text("owner_id").references(() => user.id, { onDelete: "set null" } ),
	propertyId: integer("property_id").references(() => properties.id, { onDelete: "set null" } ),
	guestName: text("guest_name").notNull(),
	guestEmail: text("guest_email").notNull(),
	guestPhone: text("guest_phone"),
	subject: text().notNull(),
	message: text().notNull(),
	enquiryType: text("enquiry_type").default("general").notNull(),
	status: text().default("new").notNull(),
	priority: text().default("medium"),
	assignedTo: text("assigned_to"),
	source: text().default("website"),
	checkInDate: text("check_in_date"),
	checkOutDate: text("check_out_date"),
	numberOfGuests: integer("number_of_guests"),
	budget: real(),
	notes: text(),
	followUpDate: text("follow_up_date"),
	createdAt: text("created_at").notNull(),
	updatedAt: text("updated_at").notNull(),
	closedAt: text("closed_at"),
});

export const crmNotes = sqliteTable("crm_notes", {
	id: integer().primaryKey({ autoIncrement: true }).notNull(),
	entityType: text("entity_type").notNull(),
	entityId: text("entity_id").notNull(),
	noteType: text("note_type").default("note"),
	title: text(),
	content: text().notNull(),
	priority: text().default("normal"),
	dueDate: text("due_date"),
	isCompleted: integer("is_completed").default(0),
	completedAt: text("completed_at"),
	createdBy: text("created_by"),
	assignedTo: text("assigned_to"),
	createdAt: text("created_at").notNull(),
	updatedAt: text("updated_at").notNull(),
});

export const crmOwnerProfiles = sqliteTable("crm_owner_profiles", {
	id: integer().primaryKey({ autoIncrement: true }).notNull(),
	userId: text("user_id").notNull().references(() => user.id, { onDelete: "cascade" } ),
	businessName: text("business_name"),
	website: text(),
	address: text(),
	city: text(),
	state: text(),
	postalCode: text("postal_code"),
	country: text().default("UK"),
	alternatePhone: text("alternate_phone"),
	alternateEmail: text("alternate_email"),
	taxId: text("tax_id"),
	businessType: text("business_type"),
	registrationNumber: text("registration_number"),
	preferredContactMethod: text("preferred_contact_method").default("email"),
	notes: text(),
	tags: text(),
	source: text().default("website"),
	status: text().default("active").notNull(),
	createdAt: text("created_at").notNull(),
	updatedAt: text("updated_at").notNull(),
},
(table) => [
	uniqueIndex("crm_owner_profiles_user_id_unique").on(table.userId),
]);

export const crmPropertyLinks = sqliteTable("crm_property_links", {
	id: integer().primaryKey({ autoIncrement: true }).notNull(),
	ownerId: text("owner_id").notNull().references(() => user.id, { onDelete: "cascade" } ),
	propertyId: integer("property_id").references(() => properties.id, { onDelete: "cascade" } ),
	linkStatus: text("link_status").default("active").notNull(),
	ownershipType: text("ownership_type").default("full"),
	commissionRate: real("commission_rate"),
	contractStartDate: text("contract_start_date"),
	contractEndDate: text("contract_end_date"),
	notes: text(),
	createdAt: text("created_at").notNull(),
	updatedAt: text("updated_at").notNull(),
});

export const enquiries = sqliteTable("enquiries", {
	id: integer().primaryKey({ autoIncrement: true }).notNull(),
	firstName: text("first_name").notNull(),
	lastName: text("last_name").notNull(),
	email: text().notNull(),
	phone: text(),
	subject: text().notNull(),
	message: text().notNull(),
	enquiryType: text("enquiry_type").default("general").notNull(),
	source: text().default("website"),
	status: text().default("new").notNull(),
	priority: text().default("medium"),
	assignedTo: text("assigned_to"),
	propertyId: integer("property_id").references(() => properties.id, { onDelete: "set null" } ),
	checkInDate: text("check_in_date"),
	checkOutDate: text("check_out_date"),
	numberOfGuests: integer("number_of_guests"),
	occasion: text(),
	budget: real(),
	preferredLocations: text("preferred_locations"),
	specialRequests: text("special_requests"),
	referralSource: text("referral_source"),
	marketingConsent: integer("marketing_consent").default(0),
	ipAddress: text("ip_address"),
	userAgent: text("user_agent"),
	adminNotes: text("admin_notes"),
	internalNotes: text("internal_notes"),
	responseTemplate: text("response_template"),
	respondedAt: text("responded_at"),
	respondedBy: text("responded_by"),
	resolvedAt: text("resolved_at"),
	metadata: text(),
	createdAt: text("created_at").notNull(),
	updatedAt: text("updated_at").notNull(),
});

export const invoices = sqliteTable("invoices", {
	id: integer().primaryKey({ autoIncrement: true }).notNull(),
	userId: text("user_id").notNull().references(() => user.id, { onDelete: "cascade" } ),
	subscriptionId: integer("subscription_id").references(() => subscriptions.id, { onDelete: "set null" } ),
	stripeInvoiceId: text("stripe_invoice_id"),
	stripePaymentIntentId: text("stripe_payment_intent_id"),
	invoiceNumber: text("invoice_number").notNull(),
	status: text().default("draft").notNull(),
	description: text(),
	amountDue: real("amount_due").notNull(),
	amountPaid: real("amount_paid"),
	amountRemaining: real("amount_remaining").notNull(),
	currency: text().default("GBP").notNull(),
	taxAmount: real("tax_amount"),
	subtotal: real().notNull(),
	total: real().notNull(),
	dueDate: text("due_date"),
	paidAt: text("paid_at"),
	invoiceDate: text("invoice_date").notNull(),
	periodStart: text("period_start"),
	periodEnd: text("period_end"),
	billingReason: text("billing_reason"),
	customerEmail: text("customer_email").notNull(),
	customerName: text("customer_name").notNull(),
	invoicePdf: text("invoice_pdf"),
	hostedInvoiceUrl: text("hosted_invoice_url"),
	metadata: text(),
	createdAt: text("created_at").notNull(),
	updatedAt: text("updated_at").notNull(),
},
(table) => [
	uniqueIndex("invoices_invoice_number_unique").on(table.invoiceNumber),
	uniqueIndex("invoices_stripe_invoice_id_unique").on(table.stripeInvoiceId),
]);

export const media = sqliteTable("media", {
	id: integer().primaryKey({ autoIncrement: true }).notNull(),
	fileName: text("file_name").notNull(),
	fileUrl: text("file_url").notNull(),
	fileType: text("file_type").notNull(),
	mimeType: text("mime_type").notNull(),
	fileSize: integer("file_size").notNull(),
	width: integer(),
	height: integer(),
	duration: integer(),
	altText: text("alt_text"),
	caption: text(),
	description: text(),
	title: text(),
	entityType: text("entity_type"),
	entityId: text("entity_id"),
	uploadedBy: text("uploaded_by").references(() => user.id, { onDelete: "set null" } ),
	folder: text().default("general"),
	tags: text(),
	isPublic: integer("is_public").default(1),
	thumbnailUrl: text("thumbnail_url"),
	metadata: text(),
	storageProvider: text("storage_provider").default("supabase"),
	storageKey: text("storage_key"),
	createdAt: text("created_at").notNull(),
	updatedAt: text("updated_at").notNull(),
},
(table) => [
	uniqueIndex("media_file_url_unique").on(table.fileUrl),
]);

export const subscriptions = sqliteTable("subscriptions", {
	id: integer().primaryKey({ autoIncrement: true }).notNull(),
	userId: text("user_id").notNull().references(() => user.id, { onDelete: "cascade" } ),
	stripeSubscriptionId: text("stripe_subscription_id"),
	stripePriceId: text("stripe_price_id"),
	stripeCustomerId: text("stripe_customer_id"),
	planName: text("plan_name").notNull(),
	planType: text("plan_type").notNull(),
	status: text().default("active").notNull(),
	currentPeriodStart: text("current_period_start").notNull(),
	currentPeriodEnd: text("current_period_end").notNull(),
	cancelAtPeriodEnd: integer("cancel_at_period_end").default(0),
	cancelledAt: text("cancelled_at"),
	trialStart: text("trial_start"),
	trialEnd: text("trial_end"),
	amount: real().notNull(),
	currency: text().default("GBP").notNull(),
	interval: text().notNull(),
	intervalCount: integer("interval_count").default(1),
	metadata: text(),
	createdAt: text("created_at").notNull(),
	updatedAt: text("updated_at").notNull(),
},
(table) => [
	uniqueIndex("subscriptions_stripe_subscription_id_unique").on(table.stripeSubscriptionId),
]);

export const payments = sqliteTable("payments", {
	id: integer().primaryKey({ autoIncrement: true }).notNull(),
	userId: text("user_id").notNull().references(() => user.id, { onDelete: "cascade" } ),
	stripeCustomerId: text("stripe_customer_id"),
	stripePaymentIntentId: text("stripe_payment_intent_id"),
	stripeChargeId: text("stripe_charge_id"),
	stripeInvoiceId: text("stripe_invoice_id"),
	stripeSubscriptionId: text("stripe_subscription_id"),
	amount: real().notNull(),
	currency: text().default("GBP").notNull(),
	paymentStatus: text("payment_status").notNull(),
	paymentMethod: text("payment_method"),
	paymentMethodBrand: text("payment_method_brand"),
	paymentMethodLast4: text("payment_method_last4"),
	description: text(),
	billingReason: text("billing_reason"),
	receiptUrl: text("receipt_url"),
	receiptEmail: text("receipt_email"),
	refundAmount: real("refund_amount"),
	refundedAt: text("refunded_at"),
	refundReason: text("refund_reason"),
	invoiceId: integer("invoice_id").references(() => invoices.id, { onDelete: "set null" } ),
	subscriptionId: integer("subscription_id").references(() => subscriptions.id, { onDelete: "set null" } ),
	bookingId: integer("booking_id").references(() => bookings.id, { onDelete: "set null" } ),
	failureCode: text("failure_code"),
	failureMessage: text("failure_message"),
	networkStatus: text("network_status"),
	riskLevel: text("risk_level"),
	riskScore: integer("risk_score"),
	metadata: text(),
	stripeEventId: text("stripe_event_id"),
	processedAt: text("processed_at"),
	createdAt: text("created_at").notNull(),
	updatedAt: text("updated_at").notNull(),
	stripeSessionId: text("stripe_session_id"),
	subscriptionPlan: text("subscription_plan"),
	userRole: text("user_role"),
},
(table) => [
	uniqueIndex("payments_stripe_payment_intent_id_unique").on(table.stripePaymentIntentId),
]);

export const propertyReviews = sqliteTable("property_reviews", {
	id: integer().primaryKey({ autoIncrement: true }).notNull(),
	propertyId: integer("property_id").notNull().references(() => properties.id, { onDelete: "cascade" } ),
	bookingId: integer("booking_id").references(() => bookings.id, { onDelete: "set null" } ),
	guestName: text("guest_name").notNull(),
	guestEmail: text("guest_email"),
	rating: integer().notNull(),
	title: text(),
	review: text().notNull(),
	cleanliness: integer(),
	accuracy: integer(),
	communication: integer(),
	location: integer(),
	value: integer(),
	isVerified: integer("is_verified").default(0),
	isPublished: integer("is_published").default(1),
	ownerResponse: text("owner_response"),
	respondedAt: text("responded_at"),
	createdAt: text("created_at").notNull(),
	updatedAt: text("updated_at").notNull(),
});

export const availabilityCalendar = sqliteTable("availability_calendar", {
	id: integer().primaryKey({ autoIncrement: true }).notNull(),
	propertyId: integer("property_id").notNull().references(() => properties.id, { onDelete: "cascade" } ),
	date: text().notNull(),
	isAvailable: integer("is_available").default(1),
	status: text().default("available").notNull(),
	price: real(),
	minimumStay: integer("minimum_stay").default(1),
	bookingId: integer("booking_id").references(() => bookings.id, { onDelete: "set null" } ),
	notes: text(),
	createdAt: text("created_at").notNull(),
	updatedAt: text("updated_at").notNull(),
});

export const orchardsPayments = sqliteTable("orchards_payments", {
	id: integer().primaryKey({ autoIncrement: true }).notNull(),
	bookingId: integer("booking_id").notNull().references(() => bookings.id, { onDelete: "cascade" } ),
	orchardsTransactionId: text("orchards_transaction_id"),
	orchardsPaymentUrl: text("orchards_payment_url"),
	paymentType: text("payment_type").notNull(),
	amount: real().notNull(),
	currency: text().default("GBP").notNull(),
	status: text().default("pending").notNull(),
	paidAt: text("paid_at"),
	refundedAt: text("refunded_at"),
	failureReason: text("failure_reason"),
	metadata: text(),
	createdAt: text("created_at").notNull(),
	updatedAt: text("updated_at").notNull(),
},
(table) => [
	uniqueIndex("orchards_payments_orchards_transaction_id_unique").on(table.orchardsTransactionId),
]);

export const seasonalPricing = sqliteTable("seasonal_pricing", {
	id: integer().primaryKey({ autoIncrement: true }).notNull(),
	propertyId: integer("property_id").notNull().references(() => properties.id, { onDelete: "cascade" } ),
	name: text().notNull(),
	seasonType: text("season_type").notNull(),
	startDate: text("start_date").notNull(),
	endDate: text("end_date").notNull(),
	pricePerNight: real("price_per_night").notNull(),
	minimumStay: integer("minimum_stay"),
	dayType: text("day_type").default("any").notNull(),
	isActive: integer("is_active").default(1),
	priority: integer().default(0),
	createdAt: text("created_at").notNull(),
	updatedAt: text("updated_at").notNull(),
});

export const specialDatePricing = sqliteTable("special_date_pricing", {
	id: integer().primaryKey({ autoIncrement: true }).notNull(),
	propertyId: integer("property_id").notNull().references(() => properties.id, { onDelete: "cascade" } ),
	name: text().notNull(),
	date: text().notNull(),
	endDate: text("end_date"),
	pricePerNight: real("price_per_night").notNull(),
	minimumStay: integer("minimum_stay"),
	isAvailable: integer("is_available").default(1),
	createdAt: text("created_at").notNull(),
	updatedAt: text("updated_at").notNull(),
});

export const performanceStats = sqliteTable("performance_stats", {
	id: integer().primaryKey({ autoIncrement: true }).notNull(),
	entityType: text("entity_type").notNull(),
	entityId: text("entity_id"),
	period: text().notNull(),
	periodStart: text("period_start").notNull(),
	periodEnd: text("period_end").notNull(),
	pageViews: integer("page_views").default(0),
	uniqueVisitors: integer("unique_visitors").default(0),
	avgSessionDuration: integer("avg_session_duration").default(0),
	bounceRate: real("bounce_rate"),
	totalEnquiries: integer("total_enquiries").default(0),
	newEnquiries: integer("new_enquiries").default(0),
	inProgressEnquiries: integer("in_progress_enquiries").default(0),
	resolvedEnquiries: integer("resolved_enquiries").default(0),
	avgResponseTime: integer("avg_response_time").default(0),
	conversionRate: real("conversion_rate"),
	totalBookings: integer("total_bookings").default(0),
	confirmedBookings: integer("confirmed_bookings").default(0),
	cancelledBookings: integer("cancelled_bookings").default(0),
	pendingBookings: integer("pending_bookings").default(0),
	totalRevenue: real("total_revenue"),
	avgBookingValue: real("avg_booking_value"),
	occupancyRate: real("occupancy_rate"),
	totalGuests: integer("total_guests").default(0),
	returningGuests: integer("returning_guests").default(0),
	avgGuestsPerBooking: real("avg_guests_per_booking"),
	totalReviews: integer("total_reviews").default(0),
	avgRating: real("avg_rating"),
	fiveStarReviews: integer("five_star_reviews").default(0),
	fourStarReviews: integer("four_star_reviews").default(0),
	threeStarReviews: integer("three_star_reviews").default(0),
	twoStarReviews: integer("two_star_reviews").default(0),
	oneStarReviews: integer("one_star_reviews").default(0),
	depositsPaid: real("deposits_paid"),
	balancesPaid: real("balances_paid"),
	pendingPayments: real("pending_payments"),
	refundsIssued: real("refunds_issued"),
	emailSent: integer("email_sent").default(0),
	emailOpened: integer("email_opened").default(0),
	emailClicked: integer("email_clicked").default(0),
	emailOpenRate: real("email_open_rate"),
	emailClickRate: real("email_click_rate"),
	metadata: text(),
	calculatedAt: text("calculated_at").notNull(),
	createdAt: text("created_at").notNull(),
	updatedAt: text("updated_at").notNull(),
});

